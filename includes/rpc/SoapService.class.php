<?php
namespace includes\rpc;

require_once('AbstractRpcService.class.php');
require_once('RpcResponse.class.php');
require_once('DummyRpcResponseWriter.class.php');

/**
  * SOAP Service
  *
  * Implementation of SOAP 1.1 and WSDL 1.1
  *
  * The WSDL (Service descriptor) is autogenerated based on the list of published method.
  * The consequence hereof is that all published methods are visibile through the WSDL
  * which is accessible by adding "?wsdl" to the query
  *
  * Data from PHP is converted into the following SOAP types:
  * - binary = SOAP-ENC:base64Binary (PHP 6 only)
  * - string = SOAP-ENC:string
  * - integer = SOAP-ENC:long
  * - float = SOAP-ENC:double
  * - bool = SOAP-ENC:boolean
  * - array = SOAP-ENC:Array or apache:Map
  * - object = {http://xml.apache.org/xml-soap}Map
  * - NULL = Null values have no type, but xsi:null=1
  *
  * Apart from data types from xsi (XML Schema Instance) and SOAP-ENC (SOAP 1.1),
  * the SOAP service supportes {http://xml.apache.org/xml-soap}Map and {http://xml.apache.org/xml-soap}Vector from the Apache AXIS
  * project
  *
  * The service fave four extra protperties:
  * - PROPERTY_NAME = Name of service. Defaults to base of file name
  * - PROPERTY_WSDL_NAMESPACE = Namespace name. Defaults to request URL
  * - PROPERTY_BINDING_NAMESPACE = Service namespace. Defaults to the request URL without query arguments
  * - PROPERTY_LOCATION = Location of service. Defaults to request URL without query arguments
  *
  * The SoapService does not make use of the SoapServer API in PHP
  */
class SoapService extends AbstractRpcService
{
	const PROPERTY_NAME = 300;
	const PROPERTY_WSDL_NAMESPACE = 301;
	const PROPERTY_BINDING_NAMESPACE = 303;
	const PROPERTY_LOCATION = 304;

	const NAMESPACE_WSDL = 'http://schemas.xmlsoap.org/wsdl/';
	const NAMESPACE_WSDL_SOAP = 'http://schemas.xmlsoap.org/wsdl/soap/';
	const NAMESPACE_XML_SCHEMA = 'http://www.w3.org/2001/XMLSchema';
	const NAMESPACE_XML_SCHEMA_1999 = 'http://www.w3.org/1999/XMLSchema';
	const NAMESPACE_XML_SCHEMA_INSTANCE = 'http://www.w3.org/2001/XMLSchema-instance';
	const NAMESPACE_XML_SCHEMA_INSTANCE_1999 = 'http://www.w3.org/1999/XMLSchema-instance';
	const NAMESPACE_SOAP_ENCODING = 'http://schemas.xmlsoap.org/soap/encoding/';
	const NAMESPACE_SOAP_ENVELOPE = 'http://schemas.xmlsoap.org/soap/envelope/';
	const NAMESPACE_APACHE_XML_SOAP = 'http://xml.apache.org/xml-soap';

	const SOAP_TRANSPORT_HTTP = 'http://schemas.xmlsoap.org/soap/http';

	const PREFIX_SOAP = 'soap';
	const PREFIX_TYPE_NAMESPACE = 'tns';
	const PREFIX_XML_SCHEMA_INSTANCE = 'xsi';
	const PREFIX_SOAP_ENVELOPE = 'env';
	const PREFIX_SOAP_ENCODING = 'enc';
	const PREFIX_APACHE_XML_SOAP = 'axis';
	const PREFIX_SELF = 'm';

	const FAULTCODE_VERSION_MISMATCH = 'VersionMismatch';
	const FAULTCODE_MUST_UNDERSTAND = 'MustUNderstand';
	const FAULTCODE_CLIENT = 'Client';
	const FAULTCODE_SERVER = 'Server';

	/**
	  */
	public function __construct ()
	{
		parent::__construct('UTF-8');

		// Calculate name
		$name = basename($_SERVER['SCRIPT_NAME']);
		$pos = strpos($name, '.');
		if ($pos === FALSE)
			$this->setProperty(self::PROPERTY_NAME, $name);
		else
			$this->setProperty(self::PROPERTY_NAME, substr($name, 0, $pos));

		// Calculate namespace
		if ($_SERVER['SERVER_PORT'] == 443)
			$namespace = 'https://'.$_SERVER['HTTP_HOST'];
		else if ($_SERVER['SERVER_PORT'] == 80)
			$namespace = 'http://'.$_SERVER['HTTP_HOST'];
		else
			$namespace = 'http://'.$_SERVER['HTTP_HOST'].':'.$_SERVER['SERVER_PORT'];
		$namespace .= $_SERVER['SCRIPT_NAME'];
		$this->setProperty(self::PROPERTY_LOCATION, $namespace);

		$this->setProperty(self::PROPERTY_WSDL_NAMESPACE, $namespace.$_SERVER['REQUEST_URI']);

		$this->setProperty(self::PROPERTY_BINDING_NAMESPACE, $this->getProperty(self::PROPERTY_LOCATION));
	}

	/**
	  * @param \DomDocument $doc
	  * @return \DomElement
	  */
	private function createWsdlDefinitionsElement (\DomDocument $doc)
	{
		$definitions = $doc->createElement('definitions');
		$definitions->setAttribute('name', $this->getProperty(self::PROPERTY_NAME));
		$definitions->setAttribute('targetNamespace', $this->getProperty(self::PROPERTY_WSDL_NAMESPACE));
		$definitions->setAttribute('xmlns', self::NAMESPACE_WSDL);
		$definitions->setAttribute('xmlns:'.self::PREFIX_SOAP, self::NAMESPACE_WSDL_SOAP);
		$definitions->setAttribute('xmlns:'.self::PREFIX_SOAP_ENCODING, self::NAMESPACE_SOAP_ENCODING);
//		$definitions->setAttribute('xmlns:xsd', self::NAMESPACE_XML_SCHEMA);
		$definitions->setAttribute('xmlns:'.self::PREFIX_TYPE_NAMESPACE, $this->getProperty(self::PROPERTY_WSDL_NAMESPACE));

		return $definitions;
	}

	/**
	  * @param \DomDocument $doc
	  * @param \DomElement $definitions
	  */
	private function addWsdlMessages (\DomDocument $doc, \DomElement $definitions)
	{
		foreach ($this->getMethods() as $method)
		{
			$reflection = $this->getMethodReflection($method);

			$message = $doc->createElement('message');
			$message->setAttribute('name', $method.'Request');

			foreach ($reflection->getParameters() as $argument)
			{
				$part = $doc->createElement('part');
				$part->setAttribute('name', $argument->getName());
				$part->setAttribute('type', self::PREFIX_SOAP_ENCODING.':anyType');
				$message->appendChild($part);
			}
			$definitions->appendChild($message);

			$message = $doc->createElement('message');
			$message->setAttribute('name', $method.'Response');

			$part = $doc->createElement('part');
			$part->setAttribute('name', 'result');
			$part->setAttribute('type', self::PREFIX_SOAP_ENCODING.':anyType');
			$message->appendChild($part);

			$definitions->appendChild($message);
		}
	}

	/**
	  * @param \DomDocument $doc
	  * @return \DomElement
	  */
	private function createWsdlPortType (\DomDocument $doc)
	{
		$portType = $doc->createElement('portType');
		$portType->setAttribute('name', $this->getProperty(self::PROPERTY_NAME));

		foreach ($this->getMethods() as $method)
		{
			$operation = $doc->createElement('operation');
			$operation->setAttribute('name', $method);

			$input = $doc->createElement('input');
			$input->setAttribute('message', self::PREFIX_TYPE_NAMESPACE.':'.$method.'Request');
			$operation->appendChild($input);

			$output = $doc->createElement('output');
			$output->setAttribute('message', self::PREFIX_TYPE_NAMESPACE.':'.$method.'Response');
			$operation->appendChild($output);

			$portType->appendChild($operation);
		}

		return $portType;
	}

	/**
	  * @param \DomDocument $doc
	  * @return \DomElement
	  */
	private function createWsdlBinding (\DomDocument $doc)
	{
		$binding = $doc->createElement('binding');
		$binding->setAttribute('name', $this->getProperty(self::PROPERTY_NAME));
		$binding->setAttribute('type', self::PREFIX_TYPE_NAMESPACE.':'.$this->getProperty(self::PROPERTY_NAME));

		$soapBinding = $doc->createElement(self::PREFIX_SOAP.':binding');
		$soapBinding->setAttribute('style', 'rpc');
		$soapBinding->setAttribute('transport', self::SOAP_TRANSPORT_HTTP);
		$binding->appendChild($soapBinding);

		foreach ($this->getMethods() as $method)
		{
			$operation = $doc->createElement('operation');
			$operation->setAttribute('name', $method);

			$input = $doc->createElement('input');

			$body = $doc->createElement(self::PREFIX_SOAP.':body');
			$body->setAttribute('use', 'encoded');
			$body->setAttribute('namespace', $this->getProperty(self::PROPERTY_BINDING_NAMESPACE));
			$body->setAttribute('encodingStyle', self::NAMESPACE_SOAP_ENCODING);
			$input->appendChild($body);

			$operation->appendChild($input);

			$output = $doc->createElement('output');

			$body = $doc->createElement(self::PREFIX_SOAP.':body');
			$body->setAttribute('use', 'encoded');
			$body->setAttribute('namespace', $this->getProperty(self::PROPERTY_BINDING_NAMESPACE));
			$body->setAttribute('encodingStyle', self::NAMESPACE_SOAP_ENCODING);
			$output->appendChild($body);

			$operation->appendChild($output);

			$binding->appendChild($operation);
		}

		return $binding;
	}

	/**
	  * @param \DomDocument $doc
	  * @return \DomElement
	  */
	private function createWsdlService (\DomDocument $doc)
	{
		$service = $doc->createElement('service');
		$service->setAttribute('name', $this->getProperty(self::PROPERTY_NAME));

		$port = $doc->createElement('port');
		$port->setAttribute('name', $this->getProperty(self::PROPERTY_NAME));
		$port->setAttribute('binding', self::PREFIX_TYPE_NAMESPACE.':'.$this->getProperty(self::PROPERTY_NAME));

		$address = $doc->createElement(self::PREFIX_SOAP.':address');
		$address->setAttribute('location', $this->getProperty(self::PROPERTY_LOCATION));
		$port->appendChild($address);

		$service->appendChild($port);

		return $service;
	}

	/**
	  */
	private function sendWsdl ()
	{
		$doc = new \DomDocument('1.0', 'UTF-8');

		$definitions = $this->createWsdlDefinitionsElement($doc);
		//$definitions->appendChild($this->createWsdlTypes($doc));
		$this->addWsdlMessages($doc, $definitions);
		$definitions->appendChild($this->createWsdlPortType($doc));
		$definitions->appendChild($this->createWsdlBinding($doc));
		$definitions->appendChild($this->createWsdlService($doc));

		$doc->appendChild($definitions);

		header('Content-Type: text/xml; charset=utf-8');
		echo($doc->saveXML());
	}

	/**
	  * @param \DomElement $element
	  * @param mixed $defaultValue
	  * @return mixed
	  */
	private function elementToValue (\DomElement $element, $defaultValue)
	{
		// nil values (XML Schema 2001)
		if ($element->getAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE, 'nil') == 'true')
			return $defaultValue;

		// null values (XML Schema 1999 and SOAP 1.1)
		if ($element->getAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE_1999, 'null') == '1')
			return $defaultValue;

		// References (SOAP 1.1)
		if ($element->hasAttributeNS(self::NAMESPACE_SOAP_ENCODING, 'href'))
		{
			$href = $element->getAttributeNS(self::NAMESPACE_SOAP_ENCODING, 'href');
			$hrefElement = $element->ownerDocument->getElementById($href);
			if ($hrefElement === NULL)
				return NULL;
			else
				return $this->elementToValue($hrefValue, $defaultValue);
		}

		// Assume unknown type
		$typeNS = NULL;
		$typeName = NULL;

		// Support SOAP-ENC: tags (SOAP 1.1)
		if ($element->namespaceURI == self::NAMESPACE_SOAP_ENCODING)
		{
			switch ($element->localName)
			{
				case 'Array':
				case 'Struct':
					$typeNS = self::NAMESPACE_SOAP_ENCODING;
					$typeName = $element->localName;
					break;

				case 'duration':
				case 'NOTATION':
				case 'time':
				case 'date':
				case 'gYearMonth':
				case 'gYear':
				case 'gMonthDay':
				case 'gDay':
				case 'gMonth':
				case 'boolean':
				case 'base64Binary':
				case 'hexBinary':
				case 'float':
				case 'double':
				case 'anyURI':
				case 'QName':
				case 'string':
				case 'normalizedString':
				case 'token':
				case 'language':
				case 'Name':
				case 'NMTOKEN':
				case 'NCName':
				case 'NMTOKENS':
				case 'ID':
				case 'IDREF':
				case 'ENTITY':
				case 'IDREFS':
				case 'ENTITIES':
				case 'decimal':
				case 'nonPositiveInteger':
				case 'negativeInteger':
				case 'long':
				case 'int':
				case 'short':
				case 'byte':
				case 'nonNegativeInteger':
				case 'unsignedLong':
				case 'unsignedInt':
				case 'unsignedShort':
				case 'positiveInteger':
				case 'anyType':
					$typeNS = self::NAMESPACE_XML_SCHEMA_INSTANCE;
					$typeName = $element->localName;
					break;
			}
		}

		// Get type from xsi:type
		if ($element->hasAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE, 'type') ||
			$element->hasAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE_1999, 'type'))
		{
			if ($element->hasAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE, 'type'))
				$typeString = $element->getAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE, 'type');
			else
				$typeString = $element->getAttributeNS(self::NAMESPACE_XML_SCHEMA_INSTANCE_1999, 'type');

			$typeInfo = explode(':', $typeString, 2);
			if (count($typeInfo) == 2)
			{
				$typeNS = $element->lookupNamespaceURI($typeInfo[0]);
				$typeName = $typeInfo[1];
			}
			else
			{
				$typeNS = $element->namespaceURI;
				$typeName = $typeInfo[0];
			}
		}

		// All types from xsd (XML Schema)
		if ($typeNS == self::NAMESPACE_XML_SCHEMA || $typeNS == self::NAMESPACE_XML_SCHEMA_1999 || $typeNS == self::NAMESPACE_SOAP_ENCODING)
		{
			switch ($typeName)
			{
				case 'string';
				case 'normalizedString':
				case 'token':
				case 'language':
				case 'Name':
				case 'NMTOKEN':
				case 'NCName':
				case 'NMTOKENS':
				case 'ID':
				case 'IDREF':
				case 'ENTITY':
				case 'IDREFS':
				case 'ENTITIES':
					return $this->convertFromRpcEncoding($element->textContent, $element->ownerDocument->encoding);

				case 'boolean':
					return ($element->textContent == 'true');

				case 'base64Binary':
					return base64_decode($element->textContent);

				case 'hexBinary':
					return pack('H*', $element->textContent);

				case 'float':
				case 'double':
					return (double)$element->textContent;

				case 'decimal':
				case 'nonPositiveInteger':
				case 'long':
				case 'nonNegativeInteger':
				case 'negativeInteger':
				case 'int':
				case 'unsignedLong':
				case 'positiveInteger':
				case 'short':
				case 'unsignedInt':
				case 'byte':
				case 'unsignedShort':
				case 'unsignedByte':
					return (int)$element->textContent;

				case 'anyType':
				case 'anySimpleType':
				case 'duration':
				case 'dateTime':
				case 'time':
				case 'date':
				case 'gYearMonth':
				case 'gYear':
				case 'gMonthDay':
				case 'gDay':
				case 'gMonth':
				case 'anyURI':
				case 'QName':
				case 'NOTATION':
					// TODO - Support more types
					break;
			}

			if ($typeNS == self::NAMESPACE_SOAP_ENCODING)
			{
				switch ($typeName)
				{
					case 'Array':
						$res = array();

						// TODO - Handle SOAP-ENC:arrayType, SOAP-ENC:position and SOAP-ENC:offset

						for ($child = $element->firstChild; $child !== NULL; $child = $child->nextSibling)
						{
							if ($child->nodeType == XML_ELEMENT_NODE)
								$res[] = $this->elementToValue($child, NULL);
						}

						return $res;

					case 'Struct':
						$res = array();

						for ($child = $element->firstChild; $child !== NULL; $child = $child->nextSibling)
						{
							if ($child->nodeType == XML_ELEMENT_NODE)
								$res[$child->localName] = $this->elementToValue($child, NULL);
						}

						return $res;

					case 'base64':
						return base64_decode($element->textContent);
				}
			}
		}

		// All types from apache (Apache XML SOAP)
		else if ($typeNS == self::NAMESPACE_APACHE_XML_SOAP)
		{
			switch ($typeName)
			{
				case 'Map':
					$res = array();

					for ($child = $element->firstChild; $child !== NULL; $child = $child->nextSibling)
					{
						if ($child->nodeType == XML_ELEMENT_NODE)
						{
							unset($key);
							unset($subvalue);

							for ($subChild = $child->firstChild; $subChild !== NULL; $subChild = $subChild->nextSibling)
							{
								if ($subChild->nodeType == XML_ELEMENT_NODE)
								{
									if ($subChild->localName == 'key')
										$key = (string)$this->elementToValue($subChild, NULL);
									else if ($subChild->localName == 'value')
										$value = $this->elementToValue($subChild, NULL);
								}
							}

							if (isset($key) && isset($value))
								$res[$key] = $value;
						}
					}

					return $res;

				case 'Vector':
					$res = array();

					for ($child = $element->firstChild; $child !== NULL; $child = $child->nextSibling)
					{
						if ($child->nodeType == XML_ELEMENT_NODE)
							$res[] = $this->elementToValue($child, NULL);
					}

					return $res;
			}
		}

		return $defaultValue;
	}

	/**
	  * @param \DomDocument $doc
	  * @param mixed $value
	  * @param string $name
	  */
	private function valueToElement (\DomDocument $doc, $value, $name)
	{
		$elem = $doc->createElement($name);

		if (is_integer($value))
		{
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_SOAP_ENCODING.':long');
			$elem->appendChild($doc->createTextNode($value));
		}
		else if (is_bool($value))
		{
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_SOAP_ENCODING.':boolean');
			$elem->appendChild($doc->createTextNode($value ? 'true' : 'false'));
		}
		else if (function_exists('is_binary') && is_binary($value))
		{
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_SOAP_ENCODING.':base64');
			$elem->appendChild($doc->createTextNode(base64_encode($value)));
		}
		else if (is_string($value))
		{
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_SOAP_ENCODING.':string');
			$elem->appendChild($doc->createTextNode($this->convertToRpcEncoding($value)));
		}
		else if (is_float($value))
		{
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_SOAP_ENCODING.':double');
			$elem->appendChild($doc->createTextNode($value));
		}
		else if (is_array($value))
		{
			// Verify that array is an array
			$expected = 0;
			$isArray = TRUE;
			foreach ($value as $name => $subValue)
			{
				if ($name != $expected)
				{
					$isArray = FALSE;
					break;
				}
				++$expected;
			}

			if ($isArray)
			{
				$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_SOAP_ENCODING.':Array');
				$elem->setAttribute(self::PREFIX_SOAP_ENCODING.':arrayType', self::PREFIX_SOAP_ENCODING.':anyType['.count($value).']');

				foreach ($value as $subValue)
				{
					$elem->appendChild($this->valueToElement($doc, $subValue, 'item'));
				}
			}
			else
			{
				$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_APACHE_XML_SOAP.':Map');

				foreach ($value as $name => $subValue)
				{
					$item = $doc->createElement(self::PREFIX_APACHE_XML_SOAP.':item');
					$item->appendChild($this->valueToElement($doc, $name, self::PREFIX_APACHE_XML_SOAP.':key'));
					$item->appendChild($this->valueToElement($doc, $subValue, self::PREFIX_APACHE_XML_SOAP.':value'));
					$elem->appendChild($item);
				}
			}
		}
		else if (is_object($value))
		{
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':type', self::PREFIX_APACHE_XML_SOAP.':Map');

			foreach (get_object_vars($value) as $name => $subValue)
			{
				$item = $doc->createElement(self::PREFIX_APACHE_XML_SOAP.':item');
				$item->appendChild($this->valueToElement($doc, $name, self::PREFIX_APACHE_XML_SOAP.':key'));
				$item->appendChild($this->valueToElement($doc, $subValue, self::PREFIX_APACHE_XML_SOAP.':value'));
				$elem->appendChild($item);
			}
		}
		else
			$elem->setAttribute(self::PREFIX_XML_SCHEMA_INSTANCE.':nil', 'true');

		return $elem;
	}

	/**
	  * @param \DomElement $method
	  * @return bool
	  */
	private function handleRequestElement (\DomElement $request)
	{
		$method = $request->localName;
		if ($this->hasMethod($method))
		{
			$arguments = array();

			for ($child = $request->firstChild; $child !== NULL; $child = $child->nextSibling)
			{
				if ($child->nodeType == XML_ELEMENT_NODE)
				{
					$arguments[$child->localName] = $this->elementToValue($child, NULL);
				}
			}

			try
			{
				RpcResponse::setWriter(new DummyRpcResponseWriter());
				$res = $this->invoke($method, $arguments);
				if ($res instanceof DummyRpcResponseWriter)
				{
					$this->sendSoapResponse($method, $res->getValue());
				}
				else
					$this->sendSoapResponse($method, $res);
			}
			catch (\Exception $exception)
			{
				$this->sendSoapFault(self::PREFIX_SOAP_ENVELOPE.':'.self::FAULTCODE_SERVER, 'Method returned an exception');
			}
		}
		else
		{
			$this->sendSoapFault(self::PREFIX_SOAP_ENVELOPE.':'.self::FAULTCODE_CLIENT, 'No such method');
		}
		return TRUE;
	}

	/**
	  * @param \DomElement $body
	  * @return bool
	  */
	private function handleBody (\DomElement $body)
	{
		for ($child = $body->firstChild; $child !== NULL; $child = $child->nextSibling)
		{
			if ($child->nodeType == XML_ELEMENT_NODE && $child->namespaceURI == $this->getProperty(self::PROPERTY_BINDING_NAMESPACE))
			{
				$this->handleRequestElement($child);
				return TRUE;
			}
		}

		return FALSE;
	}

	/**
	  * @param \DomElement $envelope
	  * @return bool
	  */
	private function handleEnvelope (\DomElement $envelope)
	{
		// Verify proper encoding style
		$encodingStyle = $envelope->getAttributeNS(self::NAMESPACE_SOAP_ENVELOPE, 'encodingStyle');
		if ($encodingStyle != self::NAMESPACE_SOAP_ENCODING)
			return FALSE;

		for ($child = $envelope->firstChild; $child !== NULL; $child = $child->nextSibling)
		{
			if ($child->nodeType == XML_ELEMENT_NODE && $child->namespaceURI == self::NAMESPACE_SOAP_ENVELOPE && $child->localName == 'Body')
				return $this->handleBody($child);
		}
		return FALSE;
	}

	/**
	  * @return \DomDocument
	  */
	private function createSoapEnvelope ()
	{
		$doc = new \DomDocument('1.0', 'UTF-8');

		$envelope = $doc->createElement(self::PREFIX_SOAP_ENVELOPE.':Envelope');
		$envelope->setAttribute('xmlns:'.self::PREFIX_SOAP_ENVELOPE, self::NAMESPACE_SOAP_ENVELOPE);
		$envelope->setAttribute('xmlns:'.self::PREFIX_XML_SCHEMA_INSTANCE, self::NAMESPACE_XML_SCHEMA_INSTANCE);
		$envelope->setAttribute('xmlns:'.self::PREFIX_SOAP_ENCODING, self::NAMESPACE_SOAP_ENCODING);
		$envelope->setAttribute('xmlns:'.self::PREFIX_SELF, $this->getProperty(self::PROPERTY_BINDING_NAMESPACE));
		$envelope->setAttribute('xmlns:'.self::PREFIX_APACHE_XML_SOAP, self::NAMESPACE_APACHE_XML_SOAP);
		$envelope->setAttribute(self::PREFIX_SOAP_ENVELOPE.':encodingStyle', self::NAMESPACE_SOAP_ENCODING);

		$doc->appendChild($envelope);

		return $doc;
	}

	/**
	  * @param \DomDocument $doc
	  * @param int $statusCode
	  * @param string $reason
	  */
	private function sendDocument (\DomDocument $doc, $statusCode, $reason)
	{
		header('HTTP/1.1 '.$statusCode.' '.$reason, TRUE, $statusCode);
		header('Status: '.$statusCode.' '.$reason, TRUE, $statusCode);
		header('Content-Type: text/xml; charset=utf8', TRUE, $statusCode);
		echo($doc->saveXML());
	}

	/**
	  * @param string $faultcode
	  * @param string $faultstring
	  */
	private function sendSoapFault ($faultcode, $faultstring)
	{
		$doc = $this->createSoapEnvelope();

		$body = $doc->createElement(self::PREFIX_SOAP_ENVELOPE.'Body');

		$fault = $doc->createElement(self::PREFIX_SOAP_ENVELOPE.':Fault');
		$fault->appendChild($doc->createElement('faultcode', $faultcode));
		$fault->appendChild($doc->createElement('faultstring', $faultstring));

		$body->appendChild($fault);

		$doc->documentElement->appendChild($body);

		$this->sendDocument($doc, 500, 'Internal Server Error');
	}

	/**
	  * @param string $method
	  * @param mixed $value
	  */
	private function sendSoapResponse ($method, $value)
	{
		$doc = $this->createSoapEnvelope();

		$body = $doc->createElement(self::PREFIX_SOAP_ENVELOPE.':Body');

		$response = $doc->createElement(self::PREFIX_SELF.':'.$method);
		$response->appendChild($this->valueToElement($doc, $value, self::PREFIX_SELF.':result'));

		$body->appendChild($response);

		$doc->documentElement->appendChild($body);

		$this->sendDocument($doc, 200, 'OK');
	}

	/**
	  */
	private function handleSoapRequest ()
	{
		if ($_SERVER['REQUEST_METHOD'] == 'POST')
		{
			$xml = file_get_contents('php://input');

			$doc = new \DomDocument();
			$doc->loadXML($xml);

			$envelope = $doc->documentElement;

			if ($envelope->namespaceURI == self::NAMESPACE_SOAP_ENVELOPE && $envelope->localName == 'Envelope')
			{
				if ($this->handleEnvelope($envelope))
					return;
			}
		}

		$this->sendSoapFault(self::FAULTCODE_CLIENT, 'Invalid request');
	}

	/**
	  * Execute RPC service
	  *
	  * This method will parse input data from the webserver, parsing
	  * the request, executing the proper published method and eventually
	  * encode a proper response.
	  *
	  * Ideally errors and exceptions are also handled within this method.
	  */
	public function handleRequest ()
	{
		if (array_key_exists('wsdl', $_GET))
			$this->sendWsdl();
		else
			$this->handleSoapRequest();
	}
}

?>
